function [values, plotdata] = ...
    lfp_burstAnalysis(trials, filenums, win, varargin)
%OUTPUTS
% values:  a structure with fields highscore, lowscore, highratio,
%   rawcoact, thresh, combinedscore, highratio2 as returned from
%   dg_computeCoactivation.
% plotdata:  a structure containing the following fields:
%   align:  the alignment reference event for the analysis.
%   filenames:  lfp_FileNames.
%   filenums:  <filenums> input arg.
%   options:  all optional input args.
%   numchannels:  number of channels submitted as input to
%       dg_computeCoactivation.
% 	timepts:  time points for the centers of the time bins constructed
%       by dg_computeCoactivation.
%   titlestr:  a string describing the data actually analyzed,
%       suitable for fig titling.
%   trials:  actual value of <trials> after all the subsitutions, defaults,
%       enablings, etc.
%   win:  as returned by gatherTrialData.
%
%OPTIONS
% Any of the options to dg_computeCoactivation can be specified here and
%   will be passed through on the call to dg_computeCoactivation.  The
%   following options to dg_computeCoactivation also have local effects in
%   lfp_burstAnalysis:
% 'clevel', p - sets the p level for computing confidence limits (so 90%
%   confidence implies <p> = .05, since there are two tails).  Default .05.
%
% The following options are specifically recognized by lfp_burstAnalysis
%   and are not passed through to dg_computeCoactivation:
% 'boot', N - ignores the confidence limits generated by
%   dg_computeCoactivation, and instead performs the analysis on <N>
%   bootstrap samples of the trials, and computes confidence limits from
%   those.  The "raw" values (<rawcoact> and <rawhist>) are separately
%   computed from the actual non-bootstrapped data.
% 'keepboot' - saves a bunch of additional fields containing all the
%   individual bootstrap median results.  The following fields are saved in
%   bootnum X timebin format as values.<fieldname>_boot, where <fieldname>
%   is one of:
%       highscore
%       lowscore
%       highratio
%       rawcoact
%       thresh
%       combinedscore
%       highratio2
%   The individual values of <shufhist> are saved as
%   plotdata.shufhist_boot.  All the bootstrap results are cell vectors of
%   length <N>, containing one bootstrap median value in each cell.
%NOTES
% Preserves logical data type of lfp_Samples only if ALL channels are
% logical.
%   It may seem fishy that values.highratio(1,:) is usually equal to either
% values.highratio(2,:) or values.highratio(3,:), but that is because its
% possible values are constrained to be small integer ratios, and so the
% median and tail threshold can easily be the same 
%   Regression test: test_lfp_burstAnalysis.

%$Rev: 323 $
%$Date: 2014-04-22 19:43:25 -0400 (Tue, 22 Apr 2014) $
%$Author: dgibson $

lfp_declareGlobals;

argnum = 1;
args2delete = [];
binwidth = 5;
clevel = .05;
keepbootflag = false;
N = 0;  % number of bootstraps; 0 implies no bootstrapping.
while argnum <= length(varargin)
    switch varargin{argnum}
        case 'binsize'
            argnum = argnum + 1;
            binwidth = varargin{argnum};
        case 'boot'
            args2delete = [ args2delete argnum argnum+1 ]; %#ok<*AGROW>
            argnum = argnum + 1;
            N = varargin{argnum};
        case 'clevel'
            argnum = argnum + 1;
            clevel = varargin{argnum};
        case 'keepboot'
            keepbootflag = true;
            args2delete = [ args2delete argnum ];
        case 'numsets'
            argnum = argnum + 1;
            % do nothing, just pass into dg_computeCoactivation
        case 'numshuffles'
            argnum = argnum + 1;
            % do nothing, just pass into dg_computeCoactivation
        case 'offset'
            argnum = argnum + 1;
            % do nothing, just pass into dg_computeCoactivation
        case 'onset'
            argnum = argnum + 1;
            % do nothing, just pass into dg_computeCoactivation
        case 'plevel'
            argnum = argnum + 1;
            % do nothing, just pass into dg_computeCoactivation
        case 'verbose'
            argnum = argnum + 1;
            % do nothing, just pass into dg_computeCoactivation
        otherwise
            error('lfp_burstAnalysis:badoption', ...
                ['The option "' ...
                dg_thing2str(varargin{argnum}) '" is not recognized.'] );
    end
    argnum = argnum + 1;
end
varargin(args2delete) = [];

if nargin < 3
    win = [];
end

if nargin < 2 || isempty(filenums)
    filenums = sort(lfp_ActiveFilenums);
end
% Apply lfp_SelectedFiles as a mask to filenums:
filenums = filenums(lfp_SelectedFiles(filenums));
logicalflag = true;
for fileidx = 1:numel(filenums)
    if ~islogical(lfp_Samples{filenums(fileidx)}) %#ok<*USENS>
        logicalflag = false;
    end
end

if nargin < 1 || isempty(trials)
    trials = 1:length(lfp_SelectedTrials);
end
if ischar(trials)
    trials = lfp_parseTrialStr(trials, session);
end
% <trials> is now numeric, i.e. trialnums.
if any(trials > length(lfp_SelectedTrials))
    warning('lfp_burstAnalysis:trials', ...
        'Ignoring trials %s, which are beyond the last trial.', ...
        dg_canonicalSeries(trials(trials > length(lfp_SelectedTrials))) );
    trials(trials > length(lfp_SelectedTrials)) = [];
end
% Apply mask to trials:
trials = lfp_enabledTrials(trials);

gathertrialdataopts = {};
if logicalflag
    gathertrialdataopts{end+1} = 'logical';
end

[burstdata, interval, win] = ...
    gatherTrialData(trials, filenums, win, gathertrialdataopts{:});
if N > 0
    [bootsam, highscore, lowscore, highratio, rawhist, ...
        shufhist, rawcoact, binends, thresh, ...
        combinedscore, highratio2] = dg_bootstrap(10, N, ...
        @computeCoactivation_by_trial, ...
        (1:size(burstdata,3))', burstdata, varargin{:});
    % Extract the median values for each bootstrap
    for bootnum = 1:size(bootsam,2)
        highscore{bootnum} = highscore{bootnum}(1,:);
        lowscore{bootnum} = lowscore{bootnum}(1,:);
        highratio{bootnum} = highratio{bootnum}(1,:);
        shufhist{bootnum} = shufhist{bootnum}(:,:,1);
        combinedscore{bootnum} = combinedscore{bootnum}(1,:);
        highratio2{bootnum} = highratio2{bootnum}(1,:);
    end
    % Construct median and CLs from the bootstraps, in the same formats as
    % returned by dg_computeCoactivation
    values.highscore = prctile(cell2mat(highscore), ...
        [50 100*(1-clevel) 100*clevel]);
    values.lowscore = prctile(cell2mat(lowscore), ...
        [50 100*(1-clevel) 100*clevel]);
    values.highratio = prctile(cell2mat(highratio), ...
        [50 100*(1-clevel) 100*clevel]);
    values.thresh = prctile(cell2mat(thresh), ...
        [50 100*(1-clevel) 100*clevel]);
    values.combinedscore = prctile(cell2mat(combinedscore), ...
        [50 100*(1-clevel) 100*clevel]);
    values.highratio2 = prctile(cell2mat(highratio2), ...
        [50 100*(1-clevel) 100*clevel]);
    % the good things in life never vary
    [a, b, c, values.rawhist, d, values.rawcoact] = ...
        dg_computeCoactivation(burstdata, 'rawonly', varargin{:});
    binends = binends{1};
    if keepbootflag
        plotdata.shufhist_boot = shufhist;
        values.highscore_boot = highscore;
        values.lowscore_boot = lowscore;
        values.highratio_boot = highratio;
        values.rawcoact_boot = rawcoact;
        values.thresh_boot = thresh;
        values.combinedscore_boot = combinedscore;
        values.highratio2_boot = highratio2;
    end
else
    [values.highscore, values.lowscore, values.highratio, rawhist, ...
        shufhist, values.rawcoact, binends, values.thresh, ...
        values.combinedscore, values.highratio2] = ...
        dg_computeCoactivation(burstdata, varargin{:}); %#ok<*ASGLU>
end

rawtimepts = lfp_SamplePeriod * (interval(1):interval(2));
binnedtimepts = (rawtimepts(binends - binwidth + 1) ...
    + rawtimepts(binends)) / 2;

sessionstr = lfp_SessionNames{1};
for k = 2:length(lfp_SessionNames)
    sessionstr = [ sessionstr ' ' lfp_SessionNames{k} ]; %#ok<AGROW>
end
if isequal(lfp_TrialStyle, 'rule')
    trialstr = lfp_SelectionRule;
else
    trialstr = dg_canonicalSeries(trials);
end
plotdata.align = lfp_AlignmentRef;
plotdata.filenames = lfp_FileNames;
plotdata.filenums = filenums;
plotdata.numchannels = size(burstdata,1);
plotdata.options = varargin;
plotdata.timepts = binnedtimepts;
plotdata.titlestr = sprintf('%s, %s', sessionstr, trialstr);
plotdata.trials = trials;
plotdata.win = win;
end


function [highscore, lowscore, highratio, rawhist, shufhist, rawcoact, ...
    binends, thresh, combinedscore, highratio2] = ...
    computeCoactivation_by_trial(layeridx, activations, varargin)
% Dumb wrapper for dg_computeCoactivation to keep dg_bootstrap happy
[highscore, lowscore, highratio, rawhist, shufhist, rawcoact, ...
    binends, thresh, combinedscore, highratio2] = ...
    dg_computeCoactivation(activations(:,:,layeridx), varargin{:});
end


function [data, interval, win] = ...
    gatherTrialData(trials, filenums, win, varargin)
%[data, interval, win] = ...
%    gatherTrialData(filenums, trials, win)
% Returns a rectangular array of data, along with metadata that were used
% in constructing it.  See also lfp_getSamples.
%INPUTS
% trials:  verbatim list of trials to gather from; i.e., this value should
%   already be edited pursuant to lfp_enabledTrials as (if) desired.  It is
%   an error for it to be empty.
% filenums:  verbatim list of trials to gather from; i.e., this value
%   should already be edited pursuant to lfp_SelectedFiles as (if) desired.
%   May include NaN values, in which case the corresponding rows of <data>
%   are all NaN.
% win:  determines <interval> together with lfp_XLimAll.
%OUTPUTS
% data:  If <filenums> is a scalar, then <data> is in trials X timepoints
%   format; if <trials> is a scalar, then <data> is in filenums X
%   timepoints format; otherwise, it is in filenums X timepoints X trials
%   format.
% interval:  actual start and end points of <data> relative to the
%   reference sample
% win:  the value actually used, which is <lfp_XLimAll> if <win> is
%   initially empty.
%OPTIONS
% 'logical' - returns data as 'logical' data type.
%NOTES
%   This code was originally derived from lfp_CSCraster_gatherdata, which
% lives in lfp_CSCraster (note substitution of "window" with "win", which
% was because 'window' is actually a Matlab function.  It was originally
% meant to replace lfp_CSCraster_gatherdata, but lfp_CSCraster has several
% idiosyncratic requirements that most analysis functions don't have (the
% 'pad' option and the use of NaNs in <filenums>) that involve a lot of
% extra plumbing and testing.  I have therefore eliminated those features
% from gatherTrialData.  Such idiosyncracies should really be handled
% in wrappers to gatherTrialData.
%   lfp_gatherTrialData was considerably older (2011-04-29) than
% lfp_getSamples (2012-05-09), so I have simply embedded in this, the only
% function that uses it, so I don't have to work out the major plumbing
% headaches. - DG 18-Apr-2014.

%$Rev: 323 $
%$Date: 2014-04-22 19:43:25 -0400 (Tue, 22 Apr 2014) $
%$Author: dgibson $

global lfp_Samples lfp_XLimAll lfp_SamplePeriod

if isempty(trials)
    error('gatherTrialData:notrials', ...
        '<trials> is empty.');
end
if isempty(filenums)
    error('gatherTrialData:nofiles', ...
        '<filenums> is empty.');
end

commontimeopts = {};
logicalflag = false;
argnum = 1;
while argnum <= length(varargin)
    switch varargin{argnum}
        case 'logical'
            logicalflag = true;
        otherwise
            error('gatherTrialData:badoption', ...
                ['The option "' ...
                dg_thing2str(varargin{argnum}) '" is not recognized.'] );
    end
    argnum = argnum + 1;
end


reftime = []; %#ok<NASGU>

% Compute <interval>
if isempty(win)
    win = lfp_XLimAll;
end
% Standard window processing:  if win or lfp_XLimAll is not empty, use
% that, trimmed to recsegs; else use the common time of whole trials,
% trimmed to trial boundaries.
if ~isempty(win)
    commontimeopts{end+1} = 'recseg';
end
[interval, rawtrialinfo] = ...
    lfp_findCommonTime(trials, commontimeopts{:});
if ~isempty(win)
    winpts = round(win/lfp_SamplePeriod);
    interval(1) = max(winpts(1), interval(1));
    interval(2) = min(winpts(2), interval(2));
end
if any(rawtrialinfo(:,3)==0)
    error('gatherTrialData:noref', ...
        'The reference event is missing from trial(s) %s', ...
        dg_canonicalSeries(trials(rawtrialinfo(:,3)==0)) );
end
% <numpts> is the number of samples from each trial:
numpts = interval(2) - interval(1) + 1;
% Construct <data> based on <dataidx>, which we construct in trials X
% timepoints format relative to each <refsample> (see lfp_findCommonTime).
dataidx = repmat(rawtrialinfo(:,3), 1, numpts) ...
    + repmat(interval(1):interval(2), size(rawtrialinfo,1), 1);
if numel(trials) == 1
    % <data> is in filenums X timepoints
    data = reshape(lfp_Samples{filenums(1)}(dataidx), 1, []);
    for k = 2:length(filenums)
        data(k,:) = reshape(lfp_Samples{filenums(k)}(dataidx), 1, []);
    end
elseif numel(filenums) == 1
    % <data> is in trials X timepoints
    data = lfp_Samples{filenums}(dataidx);
else
    for fileidx = 1:numel(filenums)
        data(fileidx, :, :) = permute( ...
            lfp_Samples{filenums(fileidx)}(dataidx), [3 2 1]);
    end
end
if logicalflag
    data = logical(data);
end
end